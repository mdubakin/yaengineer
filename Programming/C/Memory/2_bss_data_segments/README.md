# Компиляция

```sh
> gcc main.c
```

# Анализ глобальных переменных

## Получить размер сегмента bss и data

```sh
> size a.out

   text    data     bss     dec     hex filename
   1235     558      16    1809     711 a.out
```

## Просмотр имен глобальных переменных объектного файла

Найдем расположение наших переменных в памяти:
```sh
> nm a.out | grep -E ' B | D '

0000000000004020 B __bss_start  # B означает BSS
0000000000004000 D __data_start # D означает DATA
0000000000004008 D __dso_handle
000000000000401e D _edata
0000000000004030 B _end
0000000000004024 B global_var1
0000000000004028 B global_var2
0000000000004010 D global_var3
0000000000004014 D global_var4
0000000000004018 D global_var5
0000000000004020 D __TMC_END__
```

## Просмотр содержимого сегментов bss

```sh
> objdump -s -j .bss a.out 

a.out:     file format elf64-x86-64

Contents of section .bss:
 4020 00000000 00000000 00000000 00000000  ................
```

Здесь мы видим 16 байт, заполненных нулями. Каждая группа из четырех нулей (`00000000`) представляет 4 байта памяти. Наши переменные расположены так:
- `global_var1` начинается с адреса `0x4024` (вторая группа нулей)
- `global_var2` начинается с адреса `0x4028` (третья группа нулей)

## Просмотр содержимого сегментов data

```sh
objdump -s -j .data a.out 

a.out:     file format elf64-x86-64

Contents of section .data:
 4000 00000000 00000000 08400000 00000000  .........@......
 4010 21000000 67341512 41424344 4500      !...g4..ABCDE.  
```

Здесь интересно заметить:
- `global_var3 = 33` (0x21) хранится как "21000000" из-за порядка байтов little-endian
- `global_var4 = 0x12153467` хранится как "67341512" по той же причине
- `global_var5 = "ABCDE"` можно увидеть прямо в ASCII-представлении справа

